/**
 * @file Firebase Security Rules for Goal Stack Application
 * @core_philosophy This ruleset enforces a combination of user-ownership, role-based access control (admins),
 * and public-read/owner-write patterns, with denormalization to avoid costly `get()` calls.
 * @data_structure
 *  - /competitions/{competitionId}: Public competition data with denormalized 'isFavoritedBy' for optimized read access.
 *  - /teams/{teamId}: Public team data with denormalized 'favoriteBy' for optimized read access.
 *  - /matches/{matchId}: Public match data.
 *  - /news/{newsId}: News articles, write-protected to admins only, identified by existence in /admins/{adminId}.
 *  - /admins/{adminId}: Admin user profiles; presence indicates admin role.
 *  - /users/{userId}: User-specific data, secured by owner-only access.
 * @key_security_decisions
 *  - Public read access for competitions, teams, and matches.
 *  - Admin-only write access for news articles.
 *  - Strict user-ownership for user profiles.
 *  - Denormalization of favorite lists to competitions and teams avoids expensive `get()` calls in rules.
 * @denormalization_for_authorization The `isFavoritedBy` array in `/competitions/{competitionId}` and the `favoriteBy` array in `/teams/{teamId}` are denormalized to avoid needing to read user documents to determine authorization.  The `authorId` field in `/news/{newsId}` is used in conjunction with checking for admin existence to authorize news creation.
 * @structural_segregation Admin data is segregated in `/admins/{adminId}`. User-specific data is segregated under `/users/{userId}`. Public data (competitions, teams, matches, news) resides in top-level collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to competition data and restricts writes to only allow administrators
     * @path /competitions/{competitionId}
     * @allow (get, list): if true
     * @allow (create, update, delete): if isAdmin()
     * @deny (create, update, delete): if !isAdmin()
     * @principle Allows public read, admin-controlled writes.
     */
    match /competitions/{competitionId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Allows public read access to team data and restricts writes to only allow administrators.
     * @path /teams/{teamId}
     * @allow (get, list): if true
     * @allow (create, update, delete): if isAdmin()
     * @deny (create, update, delete): if !isAdmin()
     * @principle Allows public read, admin-controlled writes.
     */
    match /teams/{teamId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Allows public read access to match data. Write access is disallowed.
     * @path /matches/{matchId}
     * @allow (get, list): if true
     * @allow create, update, delete: if false;
     * @principle Allows public read, no writes permitted.
     */
    match /matches/{matchId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows admins to create, update, and delete news articles. Public read access is allowed.
     * @path /news/{newsId}
     * @allow (get, list): if true
     * @allow create: if isAdmin() && request.resource.data.authorId == request.auth.uid;
     * @allow update, delete: if isAdmin() && isExistingOwner(resource.data.authorId);
     * @deny create: if !isAdmin() || request.resource.data.authorId != request.auth.uid;
     * @deny update, delete: if !isAdmin() || !isExistingOwner(resource.data.authorId);
     * @principle Restricts write access to admins based on document existence and ownership.
     */
    match /news/{newsId} {
      allow get, list: if true;
      allow create: if isAdmin() && request.resource.data.authorId == request.auth.uid;
      allow update: if isAdmin() && isExistingOwner(resource.data.authorId);
      allow delete: if isAdmin() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows admins to create their own profiles, but restricts modifications to only the current admin.
     * @path /admins/{adminId}
     * @allow create: if request.auth.uid == adminId;
     * @allow get: if isAdmin();
     * @allow list: if isAdmin();
     * @allow update: if isAdmin() && request.auth.uid == adminId;
     * @allow delete: if isAdmin() && request.auth.uid == adminId && resource != null;
     * @deny create: if request.auth.uid != adminId;
     * @deny update, delete: if request.auth.uid != adminId;
     * @principle Allows admin to manage their own record if they exist as an admin.
     */
    match /admins/{adminId} {
        allow get, list: if isAdmin();
        allow create: if request.auth.uid == adminId;
        allow update: if isAdmin() && request.auth.uid == adminId && resource != null;
        allow delete: if isAdmin() && request.auth.uid == adminId && resource != null;
    }

    /**
     * @description Allows a user to read and write their own user profile data.
     * @path /users/{userId}
     * @allow create: if request.auth.uid == userId;
     * @allow get, list: if isOwner(userId);
     * @allow update, delete: if isExistingOwner(userId);
     * @deny create: if request.auth.uid != userId;
     * @principle Enforces user-ownership; users can only manage their own profiles.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return request.auth.uid == userId && resource != null;
    }

    function isAdmin() {
      return exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }
  }
}